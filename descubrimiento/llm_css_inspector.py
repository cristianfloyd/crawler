#!/usr/bin/env python3
"""
LLM CSS Schema Inspector - Versi√≥n Corregida
Clase especializada para usar LLM en an√°lisis de HTML y generaci√≥n de esquemas CSS optimizados
"""

import json
import asyncio
import os
import requests
from typing import Dict, List, Optional, Tuple
from crawl4ai import AsyncWebCrawler, LLMConfig
from crawl4ai.extraction_strategy import LLMExtractionStrategy
from datetime import datetime
from dotenv import load_dotenv

# Cargar variables de entorno desde .env
load_dotenv()


class LLMCSSInspector:
    """
    Inspector que usa LLM para analizar HTML y generar esquemas CSS optimizados
    """

    def __init__(self, llm_provider: str = "openai", api_key: Optional[str] = None):
        """
        Inicializa el inspector LLM

        Args:
            llm_provider: Proveedor LLM (openai para LLM Studio, ollama, google, etc.)
            api_key: API key para el proveedor (si None, lee de variables de entorno)
        """
        self.llm_provider = llm_provider
        self.api_key = api_key or self._get_api_key()
        self.analysis_result = None
        self.generated_schema = None

    def _get_api_key(self) -> str:
        """Obtiene API key de variables de entorno (.env)"""
        if self.llm_provider == "ollama":
            # Ollama no requiere API key
            return ""
        elif self.llm_provider == "google":
            key = os.getenv("GOOGLE_API_KEY", "")
        elif self.llm_provider == "openai":
            key = os.getenv("OPENAI_API_KEY", "")
        elif self.llm_provider == "anthropic":
            key = os.getenv("ANTHROPIC_API_KEY", "")
        else:
            key = os.getenv("LLM_API_KEY", "")

        if not key and self.llm_provider != "ollama":
            print(f"‚ö†Ô∏è  Advertencia: No se encontr√≥ API key para {self.llm_provider}")
            if self.llm_provider == "google":
                print("   Obt√©n tu API key en: https://aistudio.google.com/app/apikey")
            print(
                "   Aseg√∫rate de que el archivo .env existe y contiene la clave correcta"
            )

        return key  # ‚úÖ CORRECCI√ìN: Agregar return key

    def _get_llm_studio_config(self) -> Tuple[str, str]:
        """Obtiene configuraci√≥n de LLM Studio"""
        llm_studio_url = os.getenv("LLM_STUDIO_BASE_URL")
        llm_studio_model = os.getenv("LLM_STUDIO_MODEL", "gemma-3-12b")

        if not llm_studio_url:
            raise ValueError("LLM_STUDIO_BASE_URL no configurado en .env")

        return llm_studio_url, llm_studio_model

    def _call_llm_studio_direct(
        self, prompt: str, max_tokens: int = 1000
    ) -> Optional[str]:
        """
        Llama directamente a LLM Studio usando requests

        Args:
            prompt: Prompt para enviar al LLM
            max_tokens: M√°ximo n√∫mero de tokens en la respuesta

        Returns:
            Respuesta del LLM o None si falla
        """
        try:
            llm_studio_url, llm_studio_model = self._get_llm_studio_config()

            # Payload para la solicitud de chat
            payload = {
                "model": f"google/{llm_studio_model}",
                "messages": [{"role": "user", "content": prompt}],
                "max_tokens": max_tokens,
                "temperature": 0.7,
            }

            headers = {"Content-Type": "application/json"}

            print(f"   üì° Enviando solicitud a LLM Studio: {llm_studio_url}")

            response = requests.post(
                f"{llm_studio_url}/v1/chat/completions",
                json=payload,
                headers=headers,
                timeout=60,
            )

            if response.status_code == 200:
                result = response.json()
                content = (
                    result.get("choices", [{}])[0].get("message", {}).get("content", "")
                )
                print(f"   ‚úÖ LLM Studio respondi√≥ correctamente")
                return content
            else:
                print(f"   ‚ùå Error HTTP {response.status_code}: {response.text}")
                return None

        except Exception as e:
            print(f"   ‚ùå Error llamando a LLM Studio: {e}")
            return None

    def _get_llm_provider_string(self) -> str:
        """Genera string de proveedor para LLMConfig"""
        if os.getenv("LLM_STUDIO_BASE_URL"):
            # LLM Studio usa API compatible con OpenAI
            model = os.getenv("LLM_STUDIO_MODEL", "gemma-3")
            return f"openai/{model}"
        elif self.llm_provider == "ollama":
            model = os.getenv("OLLAMA_MODEL", "llama3.3")
            return f"ollama/{model}"
        elif self.llm_provider == "google":
            model = os.getenv("GEMINI_MODEL", "gemini-1.5-pro")
            return f"google/{model}"
        elif self.llm_provider == "openai":
            return "openai/gpt-4"
        elif self.llm_provider == "anthropic":
            return "anthropic/claude-3-sonnet"
        else:
            return f"{self.llm_provider}/default"

    def _get_llm_config(self) -> LLMConfig:
        """Crea configuraci√≥n LLM apropiada"""
        config_params = {"provider": self._get_llm_provider_string()}

        # Configurar para LLM Studio local
        llm_studio_base_url = os.getenv("LLM_STUDIO_BASE_URL")
        if llm_studio_base_url is not None:
            # ‚úÖ CORRECCI√ìN: Configuraci√≥n probada que funciona
            config_params["base_url"] = llm_studio_base_url
            # LLM Studio local no requiere api_token real
            config_params["api_token"] = "not-needed"
        # Configurar para Ollama
        elif self.llm_provider == "ollama":
            base_url = os.getenv("OLLAMA_BASE_URL", "http://localhost:11434")
            config_params["base_url"] = base_url
            # Ollama no necesita API token
        else:
            # Proveedores externos requieren API token
            config_params["api_token"] = self.api_key

        return LLMConfig(**config_params)

    def _create_analysis_prompt(self, html_content: str) -> str:
        """
        Crea el prompt para que el LLM analice la estructura HTML
        """
        return f"""
        Analiza este HTML de la p√°gina de materias de la Licenciatura en Ciencias de Datos y identifica los selectores CSS exactos para extraer:

        HTML a analizar:
        {html_content[:5000]}...

        1. **Secciones principales**: 
           - CBC (Ciclo B√°sico Com√∫n)
           - Segundo Ciclo (materias obligatorias)
           - Tercer Ciclo (electivas y tesis)

        2. **Nombres de materias**: 
           - Elementos que contienen nombres como "√Ålgebra I", "Algoritmos y Estructuras de Datos I"
           - Probable que est√©n en H3, H4 o elementos espec√≠ficos

        3. **Descripciones de materias**:
           - Texto que sigue a cada nombre de materia
           - Informaci√≥n adicional sobre prerrequisitos, contenido

        4. **Informaci√≥n de orientaciones**:
           - Menciones de "640 horas", "electivas", "orientaciones"
           - Listas de caminos como "Data", "Investigaci√≥n Operativa"

        **IMPORTANTE**: 
        - Proporciona selectores CSS espec√≠ficos y precisos
        - Indica la jerarqu√≠a HTML real que observas
        - Si hay contenido din√°mico, mencionalo
        - Sugiere selectores alternativos si los principales fallan

        Responde en formato JSON con esta estructura:
        {{
          "analisis_estructura": "descripci√≥n de lo que encontraste",
          "selectores_principales": {{
            "secciones": "selector CSS para secciones",
            "materias": "selector CSS para nombres de materias", 
            "descripciones": "selector CSS para descripciones",
            "orientaciones": "selector CSS para info de orientaciones"
          }},
          "selectores_alternativos": {{
            "materias_alt": "selector alternativo para materias",
            "descripciones_alt": "selector alternativo para descripciones"
          }},
          "estructura_detectada": {{
            "cbc_presente": true/false,
            "segundo_ciclo_presente": true/false,
            "tercer_ciclo_presente": true/false,
            "contenido_dinamico": true/false
          }},
          "recomendaciones": "sugerencias para mejorar extracci√≥n"
        }}
        """

    def _create_schema_generation_prompt(self, analysis_data: dict) -> str:
        """
        Crea prompt para generar esquema CSS basado en an√°lisis
        """
        return f"""
        Bas√°ndote en este an√°lisis de la estructura HTML:
        {json.dumps(analysis_data, indent=2)}

        Genera un esquema JsonCssExtractionStrategy √≥ptimo para Crawl4AI.

        El esquema debe extraer:
        1. **Encabezados de secci√≥n** (H3/H2 que indican CBC, Segundo Ciclo, etc.)
        2. **Materias individuales** (nombres limpios)
        3. **Contenido descriptivo** (informaci√≥n adicional de cada materia)
        4. **Informaci√≥n de orientaciones** (para tercer ciclo)

        Responde SOLO con un JSON v√°lido que siga esta estructura:
        {{
          "name": "materias_lcd_optimizado",
          "baseSelector": "selector_base_detectado",
          "fields": [
            {{
              "name": "secciones",
              "selector": "selector_css_para_secciones",
              "type": "list",
              "fields": [
                {{
                  "name": "titulo",
                  "selector": "self",
                  "type": "text"
                }},
                {{
                  "name": "tag_type",
                  "selector": "self",
                  "type": "attribute",
                  "attribute": "tagName"
                }}
              ]
            }},
            {{
              "name": "materias",
              "selector": "selector_css_para_materias",
              "type": "list",
              "fields": [
                {{
                  "name": "nombre",
                  "selector": "self",
                  "type": "text"
                }},
                {{
                  "name": "siguiente_texto",
                  "selector": "siguiente_elemento_css",
                  "type": "text"
                }}
              ]
            }},
            {{
              "name": "contenido_completo",
              "selector": "body",
              "type": "text"
            }}
          ]
        }}

        **CR√çTICO**: Responde √öNICAMENTE con JSON v√°lido, sin texto adicional.
        """

    async def analyze_html_structure(self, url: str) -> Tuple[bool, dict]:
        """
        Analiza la estructura HTML usando LLM Studio con requests directos

        Returns:
            Tuple[bool, dict]: (√©xito, datos_de_an√°lisis)
        """
        print("üß† Iniciando an√°lisis LLM de estructura HTML...")

        try:
            # Obtener HTML usando Crawl4AI
            async with AsyncWebCrawler(
                verbose=False,
                headless=True,
                always_by_pass_cache=True,
                browser_type="chromium",
            ) as crawler:

                print("   üìÑ Obteniendo HTML de la p√°gina...")
                result = await crawler.arun(url=url, bypass_cache=True)

                if not result or not result.html:
                    print("   ‚ùå No se pudo obtener HTML")
                    return False, {"error": "No HTML content"}

                html_content = result.html
                print(f"   ‚úÖ HTML obtenido: {len(html_content)} caracteres")

                # Crear prompt para an√°lisis
                prompt = self._create_analysis_prompt(html_content)

                # Llamar a LLM Studio directamente
                print("   üß† Enviando HTML al LLM para an√°lisis...")
                llm_response = self._call_llm_studio_direct(prompt, max_tokens=2000)

                if not llm_response:
                    print("   ‚ùå LLM Studio no respondi√≥")
                    return False, {"error": "No response from LLM Studio"}

                print("   ‚úÖ LLM an√°lisis completado")

                try:
                    # Limpiar respuesta si tiene markdown
                    content = llm_response.strip()
                    if content.startswith("```json"):
                        content = (
                            content.replace("```json", "").replace("```", "").strip()
                        )

                    # ‚úÖ MEJORA: Extraer solo la parte JSON v√°lida
                    # Buscar el primer { y el √∫ltimo } para extraer solo el JSON
                    start_idx = content.find("{")
                    end_idx = content.rfind("}")

                    if start_idx != -1 and end_idx != -1 and end_idx > start_idx:
                        json_content = content[start_idx : end_idx + 1]
                        print(
                            f"   üîß Extrayendo JSON v√°lido (l√≠neas {start_idx}-{end_idx})"
                        )
                    else:
                        json_content = content

                    analysis_data = json.loads(json_content)
                    self.analysis_result = analysis_data

                    print("   üìä Resultados del an√°lisis:")
                    print(
                        f"      - CBC presente: {analysis_data.get('estructura_detectada', {}).get('cbc_presente', '?')}"
                    )
                    print(
                        f"      - Segundo ciclo: {analysis_data.get('estructura_detectada', {}).get('segundo_ciclo_presente', '?')}"
                    )
                    print(
                        f"      - Tercer ciclo: {analysis_data.get('estructura_detectada', {}).get('tercer_ciclo_presente', '?')}"
                    )
                    print(
                        f"      - Contenido din√°mico: {analysis_data.get('estructura_detectada', {}).get('contenido_dinamico', '?')}"
                    )

                    return True, analysis_data

                except json.JSONDecodeError as e:
                    print(f"   ‚ùå Error parseando respuesta LLM: {e}")
                    print(f"   üìÑ Contenido recibido: {llm_response[:500]}...")
                    return False, {
                        "error": "JSON parsing failed",
                        "raw_content": llm_response,
                    }

        except Exception as e:
            print(f"   ‚ùå Error en an√°lisis LLM: {e}")
            return False, {"error": str(e)}

    async def generate_css_schema(self, analysis_data: dict) -> Tuple[bool, dict]:
        """
        Genera esquema CSS optimizado basado en an√°lisis LLM

        Args:
            analysis_data: Datos del an√°lisis previo

        Returns:
            Tuple[bool, dict]: (√©xito, esquema_css)
        """
        print("üîß Generando esquema CSS optimizado...")

        try:
            # Crear prompt para generaci√≥n de esquema
            prompt = self._create_schema_generation_prompt(analysis_data)

            print("   üéØ Solicitando esquema CSS al LLM...")
            llm_response = self._call_llm_studio_direct(prompt, max_tokens=1500)

            if not llm_response:
                print("   ‚ùå LLM Studio no devolvi√≥ esquema")
                return False, {"error": "No schema from LLM Studio"}

            print("   ‚úÖ Esquema CSS generado")

            try:
                # Limpiar respuesta si tiene markdown
                content = llm_response.strip()
                if content.startswith("```json"):
                    content = content.replace("```json", "").replace("```", "").strip()

                # ‚úÖ MEJORA: Extraer solo la parte JSON v√°lida
                # Buscar el primer { y el √∫ltimo } para extraer solo el JSON
                start_idx = content.find("{")
                end_idx = content.rfind("}")

                if start_idx != -1 and end_idx != -1 and end_idx > start_idx:
                    json_content = content[start_idx : end_idx + 1]
                    print(
                        f"   üîß Extrayendo JSON v√°lido (l√≠neas {start_idx}-{end_idx})"
                    )
                else:
                    json_content = content

                schema_data = json.loads(json_content)
                self.generated_schema = schema_data

                print("   üìã Esquema generado:")
                print(f"      - Nombre: {schema_data.get('name', 'N/A')}")
                print(
                    f"      - Base selector: {schema_data.get('baseSelector', 'N/A')}"
                )
                print(f"      - Campos: {len(schema_data.get('fields', []))}")

                return True, schema_data

            except json.JSONDecodeError as e:
                print(f"   ‚ùå Error parseando esquema CSS: {e}")
                print(f"   üìÑ Contenido recibido: {content[:500]}...")
                return False, {
                    "error": "Schema JSON parsing failed",
                    "raw_content": content,
                }

        except Exception as e:
            print(f"   ‚ùå Error generando esquema CSS: {e}")
            return False, {"error": str(e)}

    async def full_analysis_and_schema_generation(
        self, url: str
    ) -> Tuple[bool, dict, dict]:
        """
        Ejecuta an√°lisis completo: estructura HTML + generaci√≥n de esquema CSS

        Returns:
            Tuple[bool, dict, dict]: (√©xito, an√°lisis, esquema)
        """
        print("üöÄ Iniciando an√°lisis completo LLM ‚Üí CSS Schema")
        print("=" * 60)

        # Paso 1: Analizar estructura HTML
        analysis_success, analysis_data = await self.analyze_html_structure(url)

        if not analysis_success:
            print("‚ùå Fall√≥ an√°lisis de estructura HTML")
            return False, analysis_data, {}

        print("\nüîÑ Continuando con generaci√≥n de esquema...")

        # Paso 2: Generar esquema CSS
        schema_success, schema_data = await self.generate_css_schema(analysis_data)

        if not schema_success:
            print("‚ùå Fall√≥ generaci√≥n de esquema CSS")
            return False, analysis_data, schema_data

        print("\n‚úÖ An√°lisis completo exitoso!")
        print("=" * 60)

        return True, analysis_data, schema_data

    def get_fallback_schema(self) -> dict:
        """
        Retorna esquema CSS de fallback si falla la generaci√≥n por LLM
        """
        return {
            "name": "materias_lcd_fallback",
            "baseSelector": "body",
            "fields": [
                {
                    "name": "todos_los_elementos",
                    "selector": "h1, h2, h3, h4, h5, h6, p, div, li",
                    "type": "list",
                    "fields": [
                        {
                            "name": "tag",
                            "selector": "self",
                            "type": "attribute",
                            "attribute": "tagName",
                        },
                        {"name": "texto", "selector": "self", "type": "text"},
                        {
                            "name": "class",
                            "selector": "self",
                            "type": "attribute",
                            "attribute": "className",
                        },
                    ],
                }
            ],
        }

    async def test_simple_llm_extraction(self, url: str) -> Tuple[bool, str]:
        """
        Prueba simple de LLM para diagnosticar problemas
        """
        print("üß™ Ejecutando prueba simple de LLM...")

        # ‚úÖ DEBUG: Mostrar configuraci√≥n LLM
        llm_config = self._get_llm_config()
        print("   üîß Configuraci√≥n LLM:")
        print(f"      Provider: {llm_config.provider}")
        print(f"      Base URL: {getattr(llm_config, 'base_url', 'No configurado')}")
        print(
            f"      API Token: {'Configurado' if hasattr(llm_config, 'api_token') and llm_config.api_token else 'No configurado'}"
        )

        try:
            async with AsyncWebCrawler(
                verbose=False,
                headless=True,
                always_by_pass_cache=True,
                browser_type="chromium",
            ) as crawler:

                print("   üì° Enviando pregunta simple al LLM...")

                # ‚úÖ CORRECCI√ìN: Usar la configuraci√≥n LLM correcta
                result = await crawler.arun(
                    url=url,
                    extraction_strategy=LLMExtractionStrategy(
                        llm_config=llm_config,  # ‚úÖ Usar configuraci√≥n correcta
                        extraction_type="llm",
                        instruction="Describe briefly what this webpage is about in one sentence. Just respond with plain text, no JSON.",
                        chunk_token_threshold=2000,
                        apply_chunking=True,
                    ),
                    bypass_cache=True,
                )

                # ‚úÖ DEBUG: Informaci√≥n detallada del resultado
                print(f"   üîç Debug completo del resultado:")
                print(f"      Success: {result.success if result else 'No result'}")
                print(f"      Has HTML: {bool(result and result.html)}")
                print(f"      Has Markdown: {bool(result and result.markdown)}")
                print(
                    f"      Has Extracted Content: {bool(result and hasattr(result, 'extracted_content') and result.extracted_content)}"
                )
                if result and hasattr(result, "error_message") and result.error_message:
                    print(f"      Error Message: {result.error_message}")

                if result and result.extracted_content:
                    print(
                        f"   ‚úÖ LLM respuesta simple: {result.extracted_content[:200]}..."
                    )
                    return True, result.extracted_content
                else:
                    print(f"   ‚ùå LLM simple fall√≥")
                    print(
                        f"   üîç Result success: {result.success if result else 'No result'}"
                    )
                    if result and hasattr(result, "error_message"):
                        print(f"   üîç Error message: {result.error_message}")
                    return False, "No response from simple LLM test"

        except Exception as e:
            print(f"   ‚ùå Error en prueba simple: {e}")
            return False, str(e)

    def save_analysis_results(self, output_dir: str = "data"):
        """
        Guarda resultados del an√°lisis en archivos JSON
        """
        os.makedirs(output_dir, exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        if self.analysis_result:
            analysis_file = os.path.join(output_dir, f"llm_analysis_.json")
            with open(analysis_file, "w", encoding="utf-8") as f:
                json.dump(self.analysis_result, f, ensure_ascii=False, indent=2)
            print(f"üíæ An√°lisis guardado: {analysis_file}")

        if self.generated_schema:
            schema_file = os.path.join(output_dir, f"css_schema.json")
            with open(schema_file, "w", encoding="utf-8") as f:
                json.dump(self.generated_schema, f, ensure_ascii=False, indent=2)
            print(f"üíæ Esquema guardado: {schema_file}")


# Funci√≥n de prueba
async def test_llm_inspector():
    """
    Funci√≥n de prueba para el LLM CSS Inspector con LLM Studio local
    """
    print("üß™ PRUEBA: LLM CSS Inspector (LLM Studio + Requests Directos)")
    print("=" * 65)

    # Verificar que .env existe
    if not os.path.exists(".env"):
        print("‚ùå Error: Archivo .env no encontrado")
        print("   Crea un archivo .env con configuraci√≥n de LLM Studio")
        return

    # Verificar configuraci√≥n LLM Studio
    try:
        llm_studio_url = os.getenv("LLM_STUDIO_BASE_URL")
        llm_studio_model = os.getenv("LLM_STUDIO_MODEL", "gemma-3-12b")

        print(f"‚úÖ Configuraci√≥n LLM Studio:")
        print(f"   URL: {llm_studio_url}")
        print(f"   Modelo: {llm_studio_model}")

        # Crear inspector con LLM Studio
        inspector = LLMCSSInspector(llm_provider="openai", api_key=None)

        # Ejecutar an√°lisis completo
        print("\nüîß Ejecutando an√°lisis completo...")
        success, analysis, schema = await inspector.full_analysis_and_schema_generation(
            "https://lcd.exactas.uba.ar/materias"
        )

        if success:
            print("\nüéâ Prueba exitosa con LLM Studio + Requests Directos!")

            # Mostrar resumen del an√°lisis
            if analysis and "estructura_detectada" in analysis:
                est = analysis["estructura_detectada"]
                print(f"\nüìä Estructura detectada:")
                print(f"   CBC: {'‚úÖ' if est.get('cbc_presente') else '‚ùå'}")
                print(
                    f"   Segundo Ciclo: {'‚úÖ' if est.get('segundo_ciclo_presente') else '‚ùå'}"
                )
                print(
                    f"   Tercer Ciclo: {'‚úÖ' if est.get('tercer_ciclo_presente') else '‚ùå'}"
                )
                print(
                    f"   Contenido din√°mico: {'‚ö†Ô∏è' if est.get('contenido_dinamico') else '‚úÖ'}"
                )

            # Mostrar info del esquema
            if schema:
                print(f"\nüîß Esquema CSS generado:")
                print(f"   Nombre: {schema.get('name', 'N/A')}")
                print(f"   Selector base: {schema.get('baseSelector', 'N/A')}")
                print(f"   Campos: {len(schema.get('fields', []))}")

            inspector.save_analysis_results()
        else:
            print("\n‚ùå An√°lisis completo fall√≥")
            print(f"An√°lisis: {analysis}")
            print(f"Esquema: {schema}")

    except Exception as e:
        print(f"\n‚ùå Error en la prueba: {e}")


if __name__ == "__main__":
    print("üöÄ Iniciando prueba del LLM CSS Inspector con LLM Studio...")
    print("üìÅ Verificando configuraci√≥n...")
    asyncio.run(test_llm_inspector())
